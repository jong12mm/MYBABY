# JAVA_PART02
---
---
### 07 객체지향 일반
---
자료/링크
---
[수업자료]() |
[참고]() |
[참고]() |
[참고]() |
[참고]() |

개념
---

- 객체란
  -  '주체' 의 반대 , 의사나 행위의 '대상(Object)'
  -  실존(독점적,배타적 공간을 차지)하는 모든 대상(사물)
  -  자바에서는 인스턴스(Instance)라고도 부른다
  
- 객체 기본구조
  - 속성(Attribute)
    - 객체를 표현하는 데이터값
    - 저장의 대상 
    - 멤버변수 , 필드 , 상태값이라고도 부른다
    
  - 기능(Method)
    - 객체의 행위를 구현하는 로직(알고리즘) 
    - 구현의 대상
    - 매서드 , 기능 , 함수 , 행위라고도 부른다
- 객체지향Object-Oriented Programming, OOP)이란
  - 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법
 
- 클래스란
  - 객체를 정의하기 위해 선언된 자료형
  - 건물의 설계도면 정도로 이해하면 좋음

- JAVA 메모리 구조 | [참고](https://lucas-owner.tistory.com/38)
  - 스택 영역 : 메서드 호출시 할당되는 영역 / {}가 끝나는 시점에서 할당한 메모리 반환
    - 지역변수 / 매개변수
    - 생성시점 : 메서드 호출시 | 소멸시점 : 메서드 종료시(return)
  - 클래스(메서드)영역 : 공유 영역 /  프로그램 종료시까지 유지
    - 생성자 메서드 / 일반 메서드 / static 매서드 / static 변수
    - 생성시점 : 프로그램 시작시  | 소멸시점 : 프로그램 종료시
  - 힙 영역 : 객체 생성시 사용되는 공간 / 참조변수 연결시까지(GG에 의해 제거됨) | [참고-객체소멸시점](https://ahnty0122.tistory.com/127) |
    - 생성시점 : new 예약어 사용시 | 소멸시점 : 참조변수 연결해제시 자동 소멸(GG에 의한)

- [기본코드해석하기(Scanner sc = new Scanner(System.in)]()




코드
---
- 클래스 구성하기(속성-멤버변수)
- 클래스 메서드
  - 클래스 구성하기(기능-멤버메서드)
  - 클래스 구성하기(메서드의 4가지 형태)
  - 클래스 구성하기(지역변수/전역변수)
  - 클래스 구성하기(매개변수 가변인자형태)
  - 클래스 구성하기(초기값부여 - 생성자메서드)
    - 생성자 함수(메서드)
    - 객체 생성시에 한번 호출되는 특수한 메서드
    - 객체 생성시에 1회 호출
    - 객체 생성시 필요한 초기값을 부여
    - 생성자 함수는 클래스이름과 동일하며 반환자료형을 가지지 않는다.
    - 생성자 함수를 명시하지 않을때 기본적으로 컴파일러에 의해 주입되는
    - 생성자가 있는데 이를 디폴트 생성자 라고 한다.
    - 컴파일러에 의해 주입받는 디폴트 생성자는 모든 멤버의 초기값을 0(or false or null) 지정
  - 클래스 구성하기(메서드 오버로딩)
    - 오버로딩 : 매서드이름은 같게 / 매개변수는 다양하게
  - 클래스 구성하기(생성자 오버로딩)

- 정보은닉
  - 클래스 구성하기(접근한정자 - 정보은닉)
    - private
    - default
    - protected
    - public  
  - 클래스 구성하기(접근한정자 활용 - 캡슐화)
    - 목적달성을 위해 필요로하는 기능들(Steps)을 묶어서 처리
    - 캡슐화는 정보은닉을 수반한다
  - 클래스 구성하기(this)\
    - this란
    - 멤버변수 this
    - 멤서함수 this

- static
  - static 변수
  - static 메서드

- CF
  - String Class API 사용하기(문자열 다루기 관련 함수)
  - 객체 배열(1차원배열 / 2차원 배열)


---
### 08 객체지향 상속
---

자료/링크
---
[수업자료]() |
[참고]() |
[참고]() |
[참고]() |
[참고]() |

개념
---
- 상속 기본개념 | 사용이유
  - 상위클래스의 속성/기능을 하위클래스에서 받아 사용할 수 있도록 허용한 문법
  - 확장성 / 유지보수 / 가독성 
- UPCASTING | DOWNCASTING
  - UPCASTING
    - 상위클래스 참조변수 = 하위객체주소
    - 확장된 속성/기능 접근불가
    - Overriding 된 메서드에 접근가능
  - DOWNCASTING
    - 하위클래스 참조변수 = 상위객체주소
    - 확장된 속성/기능 접근가능
      
- 추상클래스 | 추상클래스의 사용이유 | 추상클래스 활용코드
  - 추상메서드를 하나이상 포함하고 있는 클래스
  - 추상클래스로는 객체생성이 불가능하다
  - UPCASTING으로 사용
- 인터페이스 | 인터페이스 사용이유 | 인터페이스 활용코드
  - 속성 : public static final
  - 기능 : 추상클래스  
  - 결합도를 낮추는데 사용
  - 규격화에 사용
 
코드
---
- 상속기본
- 오버라이딩
- UPCASTING
- DOWNCASTING
- 추상클래스
- 인터페이스
- 

[CF]객체 지향 설계의 다섯 가지 기본 원칙[SOLID] 
---
[참고-SOLID](https://velog.io/@falling_star3/Java-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)

- S - Single Responsibility Principle (단일 책임 원칙):
    -한 클래스는 변경의 이유가 하나, 즉 하나의 책임만을 가져야 합니다. 이는 클래스의 변경이 오직 한 가지 이유에 의해서만 발생해야 한다는 것을 의미합니다.
- O - Open/Closed Principle (개방-폐쇄 원칙):
    - 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 합니다. 이는 기존의 코드를 수정하지 않고도 새로운 기능을 추가할 수 있도록 설계해야 한다는 것을 의미합니다.
- L - Liskov Substitution Principle (리스코프 치환 원칙):
    - 하위 타입은 상위 타입에서 사용되는 어떤 기능이든 대체 가능해야 합니다. 즉, 상속 관계에서는 하위 클래스가 상위 클래스의 기능을 변경하지 않고 대체할 수 있어야 한다는 것을 의미합니다.
- I - Interface Segregation Principle (인터페이스 분리 원칙):
    -클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 됩니다. 인터페이스는 클라이언트가 필요로 하는 메소드들로만 분리되어야 하며, 큰 하나의 인터페이스보다는 작고 구체적인 여러 개의 인터페이스로 분리되어야 합니다.
- D - Dependency Inversion Principle (의존성 역전 원칙):
    - 고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 대신 둘 모두 추상화에 의존해야 합니다. 또한 추상화는 세부 사항에 의존해서는 안 됩니다. 세부 사항은 추상화에 의존해야 합니다.
